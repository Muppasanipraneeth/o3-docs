# Type annotations

- Follow the guidelines outlined in [React TypeScript Cheatsheets](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/).
- Always annotate your function parameters with types. This makes it easier to understand what the function does, and explicitly expresses the function's contracts.
- Rely on TypeScript's type inference for things like variable and array initialization, and in some cases, function return types. The goal of the type system is not to annotate every single variable with a type, but rather to make sure that the important parts of your code are type-safe. Read more about type inference [here](https://www.typescriptlang.org/docs/handbook/type-inference.html).
- TypeScript `interfaces` enable declaration merging and can be extended by other interfaces. This makes them more flexible than `type` aliases, which cannot be extended. If you don't need these features, prefer using `type` aliases instead.
- Don't use `any` unless you absolutely have to. Instead, use `unknown` or `never` to express the fact that you don't know the type of a variable or that a function never returns.
- Wherever possible, use the `import type` syntax when importing types. This prevents the type from being imported at runtime, which reduces the bundle size. For example:

  ```tsx
  // Prefer
  import type { User } from "@openmrs/esm-user-management";

  // Instead of
  import { User } from "@openmrs/esm-user-management";
  ```

- [Prefer union types over status enums](https://fettblog.eu/tidy-typescript-avoid-enums/). For example, prefer `type Status = "loading" | "error" | "success"` over `enum Status { Loading, Error, Success }`. This is because enums are not type safe, and can be assigned any value. For example, `Status.Loading = "error"` is a valid statement, but `Status = "error"` is not.
- Use the `jest.mocked` utility to preserve type information when mocking functions in tests. For example:

  Prefer:

  ```tsx
  const mockedShowSnackbar = jest.mocked(showSnackbar); // All the type information is preserved
  ```

  Over:

  ```tsx
  const mockedShowSnackbar = showSnackbar as jest.Mock;
  ```

- Use TypeScript's built-in utility types when possible. Common examples include:

  ```tsx
  // Make all properties optional
  type PartialUser = Partial<User>;

  // Make all properties required
  type RequiredUser = Required<User>;

  // Pick specific properties
  type UserName = Pick<User, 'firstName' | 'lastName'>;

  // Omit specific properties
  type UserWithoutPassword = Omit<User, 'password'>;

  // Extract return type from a function
  type ReturnValue = ReturnType<typeof myFunction>;
  ```

- Prefer using `const` assertions for literal types:

  ```tsx
  // This array has type readonly ["error", "success", "loading"]
  const statusLiterals = ["error", "success", "loading"] as const;
  type Status = typeof statusLiterals[number]; // "error" | "success" | "loading"
  ```

- Prefer explicit prop types for React components:

  ```tsx
  // Prefer
  interface ButtonProps {
    variant: 'primary' | 'secondary';
    onClick: () => void;
    children: React.ReactNode;
  }

  // Over
  const Button = (props: any) => { ... }
  ```