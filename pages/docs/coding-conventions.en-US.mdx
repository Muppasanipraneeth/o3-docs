import { Callout } from "nextra-theme-docs";

# Coding conventions

This is a compendium of the coding conventions we use in O3. The purpose of this document is to help us write code that is consistent and easy to maintain.

These conventions represent our collective experience and best practices for building maintainable, performant, and user-friendly frontend applications in the OpenMRS 3.x ecosystem. They cover everything from naming and project structure to state management and performance optimization.

## Who is this guide for?

- **New contributors** looking to understand our coding standards
- **Existing developers** seeking guidance on specific implementation patterns
- **Reviewers** referencing standards during code reviews
- **Technical leads** making architectural decisions

## How to use this guide

This document serves as both a reference and a learning resource. While you should aim to follow these conventions in your code, understand that they are guidelines rather than strict rules. The goal is to maintain consistency while writing high-quality, maintainable code.

If you find cases where deviating from these conventions would result in better code, feel free to discuss it with the team. Our conventions evolve as we learn and as best practices in the frontend ecosystem change.

## Table of contents

- [Project structure](#project-structure)
- [Code organization](#code-organization)
- [Naming](#naming)
- [Components](#components)
- [Type annotations](#type-annotations)
- [State management](#state-management)
- [Data fetching](#data-fetching)
- [Mutations and side effects](#mutations-and-side-effects)
- [Event handlers](#event-handlers)
- [Styling](#styling)
- [Search inputs](#search-inputs)
- [Internationalization](#internationalization)
- [Error handling](#error-handling)
- [Testing](#testing)
- [Performance](#performance)

## Project structure

O3 consists of both monorepos and standalone repositories. Monorepos are used to group domain-specific packages that are related to each other. For example, patient management concerns such as registration and search live in the [Patient Management](https://github.com/openmrs/openmrs-esm-patient-management) monorepo. Standalone repositories are used for single-purpose packages that are not related to other packages. For example, the [Form Builder](https://github.com/openmrs/openmrs-esm-form-builder) package is a standalone repository that contains functionality for building and managing form schemas.

- Monorepos should contain domain-specific packages that are related to each other. For example, patient management concerns such as registration and search live in the `openmrs-esm-patient-management` monorepo.
- Shared configuration files should generally exist at the root of the monorepo directory. These include:
  - `.eslintignore` - ESLint ignore file
  - `.eslintrc` - ESLint configuration file
  - `.prettier.config.js` - Prettier configuration file
  - `.prettierignore` - Prettier ignore file
  - `.yarnrc.yml` - Yarn configuration file
  - `tsconfig.json` - Root TypeScript configuration file
  - `turbo.json` - Turbo configuration file

  A typical convention is to place configuration files for the i18next parser, test utilities, and the Jest test setup file in a `tools` directory at the root of the monorepo:

  - `tools/i18next-parser.config.js` - i18next parser configuration file
  - `tools/setupTests.ts` - Jest test setup file
  - `tools/test-utils.tsx` - Test utilities

  Configuration files you'd expect to find at the root of each package in the monorepo include:

  - `package.json` - Manifest file for the package. This is where you should put scripts for the package.
  - `tsconfig.json` - TypeScript configuration file that extends the root TypeScript configuration file.
  - `jest.config.ts` - Jest configuration file that extends the root Jest configuration file.
  - `webpack.config.js` - Webpack configuration file that extends the root Webpack configuration file.

- Place e2e tests in the `e2e/specs` directory at the root of your repository.
- Place test mocks in the top level `__mocks__` directory at the root of your repository. Mocks should be named after the module they are mocking. For example, if you have a mock with data for the `@openmrs/esm-patient-allergies` module, your mock should be named `allergies.mock.ts`. The root-level Typescript configuration file will automatically pick up any mocks in the `__mocks__` directory courtesy of the `paths` configuration in the root `tsconfig.json` file:

  ```json
  "paths": {
    "__mocks__": ["./__mocks__"],
    "tools": ["./tools"]
  },
  ```

  This means you can import the mock in your tests using a path alias:

  ```tsx
  // TypeScript will automatically resolve the path to the mock
  import { mockAllergy } from '__mocks__';
  ```

  TypeScript automatically resolves the path to the top-level `tools` directory using the same mechanism. This means you can also import test utilities from the `tools` directory using a path alias:

  ```tsx
  // TypeScript will automatically resolve the path to the tools directory
  import { waitForLoadingToFinish } from 'tools';
  ```

## Code organization

- Colocate related files in the same directory. Each component should have its own directory containing all its associated files. This includes:
  - Component file (e.g., `patient-banner.component.tsx`)
  - Test file (e.g., `patient-banner.test.tsx`)
  - Stylesheet (e.g., `patient-banner.scss`)
  - Resource file (e.g., `patient-banner.resource.ts`)
  - Any other related files (e.g., constants, types, utilities)

  Example directory structure:
  ```
  src/
  └── patient-banner/
      ├── patient-banner.component.tsx
      ├── patient-banner.test.tsx
      ├── patient-banner.scss
      └── patient-banner.resource.ts
  ```

  This organization:
  - Makes it easier to find and modify related files
  - Simplifies refactoring and maintenance
  - Keeps the codebase modular and well-organized
  - Makes it clear which files belong to which component

- Avoid placing styles for multiple components in the same stylesheet. Instead, create a separate stylesheet for each component. This makes it easier to find the styles for a particular component.
- Use the [template app](https://github.com/openmrs/openmrs-esm-template-app) to quickly seed new O3 frontend modules:
  1. Visit the [template repository](https://github.com/openmrs/openmrs-esm-template-app)
  2. Click the green `Use this template` button
  3. Choose `Create a new repository`
  4. Follow the setup instructions in the template's README

  The template provides:
  - Correct TypeScript configuration
  - Pre-configured testing setup with Jest
  - ESLint and Prettier configurations
  - GitHub Actions workflows
  - Basic project structure following O3 conventions
  - Example components and tests

- Group imports alphabetically based on their type. The recommended order is:
  - React and framework imports (e.g., `React`, `useState`, `useEffect`)
  - External modules (e.g., `lodash`, `dayjs`, `react-i8next`)
  - Carbon component imports (e.g., `Button`, `InlineLoading`)
  - OpenMRS imports (e.g., `@openmrs/esm-framework`, `@openmrs/esm-error-handling`)
  - Local imports (components, hooks, utilities, etc.)
  - Asset imports (e.g `import styles from './user.scss'`)

  In the near future, we'll be able to use ESLint import order sorting to enforce this convention. Following this convention makes it easier to maintain consistency across the codebase.

- Consolidate library imports into a single import statement. This makes it easier to see which modules are being used and makes the code more readable. For example, prefer:

  ```tsx
  // Good
  import { Button, InlineLoading } from '@carbon/react';
  ```

  Over:

  ```tsx
  // Bad
  import { Button } from '@carbon/react';
  import { InlineLoading } from '@carbon/react';
  ```

  Note that you should still keep imports from different modules separate:

  ```tsx
  // Good - separate imports for different modules
  import { useState, useEffect } from 'react';
  import { useTranslation } from 'react-i18next';
  import { Button, DataTable } from '@carbon/react';
  import { useConfig, showSnackbar } from '@openmrs/esm-framework';
  ```

- Place type annotations and interfaces at the top of the file, after the imports and above any component code. Since TypeScript types and interfaces are development-time constructs that get removed during compilation, they don't affect the runtime behavior of your code.

   ```tsx
  import React from 'react';
  import { useTranslation } from 'react-i18next';
  import { Button } from '@carbon/react';
  import { showSnackbar } from '@openmrs/esm-framework';

  // Type definitions come after imports, before component code
  interface UserData {
    id: string;
    name: string;
    email: string;
    role: 'admin' | 'user';
  }

  type UserComponentProps = {
    userData: UserData;
    onSave: (data: UserData) => void;
    isEditable?: boolean;
  };

  // Component code follows type definitions
  export const UserComponent: React.FC<UserComponentProps> = ({ 
    userData,
    onSave,
    isEditable = false 
  }) => {
    // ... component implementation
  };
  ```

  Some key points about type placement:
  - Keep related types and interfaces grouped together
  - Place more generic types before more specific ones that might depend on them
  - Consider extracting commonly used types into a separate `types.ts` file if they're used across multiple components

  On whether to use `type` aliases or `interface` declarations:
  - Use `interface` when you need declaration merging or inheritance
  - Use `type` for unions, intersections, primitives, tuples, and utility types
  - Be consistent within your codebase - if your team has standardized on one approach, follow that convention

  ```ts
  // Use interface for object shapes
  interface UserProps {
    name: string;
    age: number;
    onSave: (data: User) => void;
  }

  // Use type for unions and more complex types
  type Status = 'loading' | 'success' | 'error';
  type ButtonKind = 'primary' | 'secondary' | 'ghost';
  type Nullable<T> = T | null;
  ```

## Naming

- Follow the guidelines in this [naming cheatsheet](https://github.com/kettanaito/naming-cheatsheet).
- Use `camelCase` for variables, functions, methods, and class names.
- Use `kebab-case` for file names and folder names.
- Components should contain the `.component` suffix in their name (e.g. `user.component.tsx`). This nomenclature is used to distinguish components from other files such as resources, stylesheets, and tests, and determines where the i18next-parser tool extracts translation keys and strings from. Translation keys and strings will not be extracted from files that do not match this convention by default.
- Components may also contain different suffixes to indicate their purpose. These custom suffixes should be used in addition to the base `.component` suffix. They include:
  - `.extension` for components that render extensions e.g. [lab-order-basket-panel.extension.tsx](https://github.com/openmrs/openmrs-esm-patient-chart/blob/main/packages/esm-patient-labs-app/src/lab-orders/lab-order-basket-panel/lab-order-basket-panel.extension.tsx#L21) for the `Lab Order Basket panel` extension.
  - `.modal` for components that render modals e.g. [delete-condition.modal.tsx](https://github.com/openmrs/openmrs-esm-patient-chart/blob/main/packages/esm-patient-conditions-app/src/conditions/delete-condition.modal.tsx) for the `Delete Conditions` modal.
  - `.workspace` for components that render forms in the workspace e.g. [order-basket.workspace.tsx](https://github.com/openmrs/openmrs-esm-patient-chart/blob/main/packages/esm-patient-orders-app/src/order-basket/order-basket.workspace.tsx#L4) for the `Order Basket` workspace.
- Unit and integration test files should contain the `.test` suffix in their name (e.g. `user.test.tsx`). Do not include the word `component` in the test file name.
- Playwright e2e tests should contain the `.spec` suffix in their name (e.g. `user.spec.ts`).
- Stylesheets should not contain `.component` suffix in their name (e.g. `user.component.scss`). This is because stylesheets are not components, and are not translated by the translation system. Instead, stylesheets should be named after the component they are styling (e.g. `user.scss`).
- Resource files that encapsulate data fetching logic should contain the `.resource` suffix in their name (e.g. `user.resource.ts`). This is to distinguish them from other files such as components, stylesheets, and tests.
- Use appropriate extensions for TypeScript files:
  - Use the `.tsx` extension for files that contain JSX.
  
  ```tsx
  // user.component.tsx
  const UserComponent: React.FC<UserComponentProps> => {
    return <div>User Component</div>
  }
  ```

  - Use the `.ts` extension for files that do not contain JSX.

  ```ts
  // user.resource.ts
  export const fetchUser = () => {
    return openmrsFetch<User>('/ws/rest/v1/user');
  }
  ```

  In most cases, you shouldn't need to use the `.tsx` extension for files outside the `src` directory.

- Follow the extension system [nomenclature guide](/docs/extension-system#nomenclature) when naming your extensions and extension slots.
- Use the file name as the component name. For example, `user.component.tsx` should contain a component named `UserComponent`. This makes it easier to find the component in the codebase.
- Avoid using DOM component prop names for different purposes. For example, avoid using the `className` prop to pass a CSS class name to a component. Instead, use a prop name that is specific to the component, such as `cssClass`.
- Use `camelCase` for prop names. This is consistent with the naming convention for variables, functions, and methods.
- Translation keys should be in `camelCase` whereas translation strings should be in `sentence case`. For example, `firstName` is a translation key whereas `First name` is it's corresponding translation string.
- Frontend modules in monorepos should have names that start with the `esm-` prefix. The name of the module should describe what the module does. For example, `esm-user-management` is a good name for a frontend module handling user management concerns and `esm-patient-chart` is a good name for a frontend module handling patient chart concerns.
- Event handler props should be named after they event they handle `e.g. onClick` for a click handler. By convention, event handler props should start with the `on` prefix, followed by a capital letter.
- State updater functions should be named after the state they update. For example, `setFirstName` is a good name for a state updater function that updates the `firstName` state.
- What to name your branches is typically down to personal preference. However, when in doubt, name your branches using the [conventional commit](https://www.conventionalcommits.org/en/v1.0.0/) type that your work conforms to, followed by a slash and a short dash-separated description of the work. Good examples include: `feat/debounced-order-basket-search`, `fix/missing-translation`, `chore/bump-dependencies` and `refactor/remove-unused-code`.

## Components

- Don't keep unused code in your components. Keeping dead code around can cause confusion and makes it harder to maintain the codebase. This includes:
  - Commented out code blocks
  - Unused imports
  - Unused props
  - Unused variables and functions
  - Dead code paths

- Validate the props passed to your component using type aliases or interfaces. This helps to catch bugs early and makes it easier to understand how the component is used. For example:

  ```tsx
  // Good - using TypeScript interfaces
  interface UserComponentProps {
    name: string;
    age: number;
    isAdmin?: boolean;
  }

  const UserComponent: React.FC<UserComponentProps> = ({ name, age, isAdmin = false }) => {
    // ...
  };
  ```

- Make sure you read through a [Carbon component's](https://react.carbondesignsystem.com/) documentation before using it. This helps you to understand the component's props and how to use them. It also helps you to understand the component's behavior and can obviate the need for writing custom code. For example, here's the [Button component documentation](https://react.carbondesignsystem.com/?path=/docs/components-button--default).
- [Use keys in lists](https://react.dev/learn/rendering-lists). This helps React to identify which items have changed, been added, or been removed. This is especially important if you are rendering a list of components that contain state.
- [Generate keys from the data itself](https://react.dev/learn/rendering-lists#where-to-get-your-key) if possible. For example, if you are rendering a list of patients from the database, use the patient's ID as the key. This ensures that the key is unique and stable across renders.
- [Avoid using effects](https://react.dev/learn/you-might-not-need-an-effect) for things that don't involve synchronizing with external systems. The distinction is nuanced and can be difficult to understand. Please read and internalize the linked article before reaching for effects. Common cases where you **don't** need to use effects include:
  - Transforming data for rendering
  - Handling user events
  - Updating the UI based on some state
  - Updating the UI based on a prop change

  Scenarios where you **do** need to use effects include:
  - Managing subscriptions or WebSocket connections
  - Controlling non-React widgets that need to be initialized with a DOM element
  - Managing browser APIs that React doesn't handle for you (e.g. notifications, microphone access, etc.)
  - Setting up event listeners or other callbacks on window or document objects

  When in doubt, ask yourself: "*Is this code synchronizing with something outside of React's control?*" 
  If not, you probably don't need an effect.

- Consider using performance optimizations like `useMemo` and `useCallback` in these specific situations:
  - When memoizing expensive computations.
  - When passing callbacks to optimized child components that rely on referential equality to prevent unnecessary renders.
  - When creating referentially stable objects or arrays that are used as dependencies in other hooks.
  - When working with context providers where value changes can trigger widespread re-renders.

  Don't treat these hooks as premature optimizations, but rather as tools for specific performance and stability needs. Read [the React docs on useMemo](https://react.dev/reference/react/useMemo#when-to-use-usememo) and [useCallback](https://react.dev/reference/react/useCallback#when-to-use-usecallback) for detailed guidance.

- Omit the value of a prop when it is explicitly `true`. For example:

  ```tsx
  // These are equivalent
  <Button disabled /> // Preferred
  <Button disabled={true} /> // More verbose, same result
  ```

  ```tsx
  // Be explicit when you need to mark a prop falsy
  <Button disabled={false} />
  ```

  ```tsx
  // This pattern applies to custom components too
  <UserComponent isAdmin /> // Preferred
  <UserComponent isAdmin={true} /> // More verbose, same result
  <UserComponent isAdmin={false} /> // Must be explicit when false
  ```

  This keeps the code cleaner and more maintainable while maintaining full functionality.

- [Keys can be used to reset the state of a component](https://react.dev/learn/preserving-and-resetting-state#resetting-a-form-with-a-key). This pattern is particularly useful when dealing with forms. When React encounters a component with a different key, it will unmount the old instance and mount a new one, effectively resetting all internal state. Examples of this include:

  - Forcing a re-render of the UserProfile component when the user switches between profiles:

  ```tsx
  // Re-render when userId changes
  <UserProfile key={userId} userId={userId} />
  ```

  - Resetting form state when switching between edit modes:

  ```tsx
  // Can be used to clear all form inputs and validation states
  <Form key={`${itemId}-${isEditMode}`} item={item} />
  ```

  - Resetting an animation instead of transitioning from a previous state:
  
  ```tsx
  // Restart animation when count changes
  <AnimatedNumber key={count} value={count} />
  ```

  The key principle is: when the key changes, React treats it as a completely different component instance, discarding all previous state. This is cleaner than manually resetting multiple state variables.

- Follow consistent code formatting, naming conventions and folder structure. This makes the codebase more readable and easier to maintain.

## Type annotations

- Follow the guidelines outlined in [React TypeScript Cheatsheets](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/).
- Always annotate your function parameters with types. This makes it easier to understand what the function does, and explicitly expresses the function's contracts.
- Rely on TypeScript's type inference for things like variable and array initialization, and in some cases, function return types. The goal of the type system is not to annotate every single variable with a type, but rather to make sure that the important parts of your code are type-safe. Read more about type inference [here](https://www.typescriptlang.org/docs/handbook/type-inference.html).
- TypeScript `interfaces` enable declaration merging and can be extended by other interfaces. This makes them more flexible than `type` aliases, which cannot be extended. If you don't need these features, prefer using `type` aliases instead.
- Don't use `any` unless you absolutely have to. Instead, use `unknown` or `never` to express the fact that you don't know the type of a variable or that a function never returns.
- Wherever possible, use the `import type` syntax when importing types. This prevents the type from being imported at runtime, which reduces the bundle size. For example:

  ```tsx
  // Prefer
  import type { User } from "@openmrs/esm-user-management";

  // Instead of
  import { User } from "@openmrs/esm-user-management";
  ```

- [Prefer union types over status enums](https://fettblog.eu/tidy-typescript-avoid-enums/). For example, prefer `type Status = "loading" | "error" | "success"` over `enum Status { Loading, Error, Success }`. This is because enums are not type safe, and can be assigned any value. For example, `Status.Loading = "error"` is a valid statement, but `Status = "error"` is not.
- Use the `jest.mocked` utility to preserve type information when mocking functions in tests. For example:

  Prefer:

  ```tsx
  const mockedShowSnackbar = jest.mocked(showSnackbar); // All the type information is preserved
  ```

  Over:

  ```tsx
  const mockedShowSnackbar = showSnackbar as jest.Mock;
  ```

## State management

- Follow the guidelines outlined [here](https://kentcdodds.com/blog/application-state-management-with-react).
- To share state between components, [lift the state up to the nearest common ancestor](https://react.dev/learn/sharing-state-between-components#) of the components that need to share the state and pass the state down to the components as props. This is the simplest way to share state between components.
- Avoid creating state variables for things that can be [computed from existing state variables](https://react.dev/learn/you-might-not-need-an-effect#updating-state-based-on-props-or-state). For example, if you have a state variable called `firstName` and another called `lastName`, don't create a third state variable called `fullName`. Instead, derive the `fullName` from the `firstName` and `lastName` state variables.

## Data fetching

- Colocate your data fetching logic in a file suffixed with `.resource`. For example, `user.resource.ts` contains the data fetching logic for the User component.
- Wherever possible, prefer abstracting your data fetching into a custom hook rather than [fetching with effects](https://react.dev/reference/react/useEffect#fetching-data-with-effects). Fetching data with effects has many [downsides](https://react.dev/reference/react/useEffect#fetching-data-with-effects) and should be avoided. Instead, prefer using [SWR](https://swr.vercel.app/) hooks.
- Use [SWR](https://swr.vercel.app/) hooks to fetch data from the backend. Use [useSWRImmutable](https://swr.vercel.app/docs/revalidation.en-US#disable-automatic-revalidations) for resources that are not expected to change often, such as concepts or backend configurations.
- Put the SWR hook in a resource file, and export it as a function. This allows us to reuse the same hook in multiple components.
- Memoize the return value of your SWR hook using `useMemo` to prevent unnecessary rerenders. This is especially important if the hook is used in a component that is rendered many times, such as a table row.
- Data fetching hooks should follow the naming convention `use<resource>`. For example, `useUser` is the hook for fetching user data.
- Use [openmrsFetch](https://github.com/openmrs/openmrs-esm-core/blob/main/packages/framework/esm-api/src/openmrs-fetch.ts) to fetch data from the backend. `openmrsFetch` is a wrapper around the `fetch` API that adds authentication and authorization headers and handles errors. Pass it to SWR hooks as the `fetcher` argument.
- Use the `error`, `isLoading`, `isValidating` and `mutate` properties of the SWR hook to handle errors, loading states and mutations. Don't recreate these properties manually.
- Use SWR's [conditional data fetching](https://swr.vercel.app/docs/conditional-fetching) pattern when the request depends on some condition. For example, if the request depends on a prop, only make the request if the prop is true.

  ```tsx
  // Only fetch user data if userId is provided
  const url = userId ? `/ws/rest/v1/user/${userId}` : null;
  const { data, error, isLoading, isValidating, mutate } = useSWR<User>(url, openmrsFetch);
  ```

## Mutations and side effects

- Use SWR's global and bound [mutate](https://swr.vercel.app/docs/mutation#mutate) APIs to mutate data in the cache. This ensures that the cache is updated consistently across the application and omits the need to reload the page to see the changes.
- Show a toast notification when a mutation succeeds. When a mutation fails, show a inline notification with an error message that communicates the reason for the failure.

## Event handlers

- Ensure that your event handlers properly define their cleanup logic. Event handlers in useEffect callbacks should always _return_ a cleanup function to prevent unexpected behaviour. For example, do this:

  ```tsx {8-10}
  useEffect(() => {
    const handleClick = () => {
      // ... handle the click event
    };

    document.addEventListener("click", handleClick);

    return () => {
      document.removeEventListener("click", handleClick);
    };
  }, []);
  ```

  Instead of this:

  ```tsx {9}
  useEffect(() => {
    const handleClick = () => {
      // ... handle the click event
    };

    document.addEventListener("click", handleClick);

    // Incorrect cleanup: Executes immediately, not when the component unmounts
    document.removeEventListener("click", handleClick);
  }, []);
  ```

## Styling

- Be wary of using global styles. They can easily lead to unintended side effects and make it difficult to reason about the codebase. Nest global styles under a class name to prevent them from affecting other components.

  ```scss
  // Avoid applying styles globally
  :global(.cds--text-input) {
    height: 3rem;
    @extend .label01;
  }

  // Prefer scoping style overrides under a class name
  .input-group {
    display: flex;
    justify-content: center;
    flex-direction: column;

    :global(.cds--text-input) {
      height: 3rem;
      @extend .label01;
    }
  }
  ```

- Put Carbon style overrides in [overrides.scss](https://github.com/openmrs/openmrs-esm-core/blob/main/packages/framework/esm-styleguide/src/_overrides.scss). This ensures that the overrides are applied consistently across the application.
- Prefer using Carbon [color](https://carbondesignsystem.com/guidelines/color/overview/), [spacing](https://carbondesignsystem.com/guidelines/spacing/overview/) and [type](https://carbondesignsystem.com/guidelines/typography/overview/) tokens over hard-coded values. Below are some examples of using tokens in code:

  ```scss
  @use "@carbon/styles/scss/colors";
  @use "@carbon/styles/scss/spacing";
  @use "@carbon/styles/scss/type";

  .listWrapper {
    margin: spacing.$spacing-05;
  }

  .resultsCount {
    @include type.type-style("label-01");
  }

  .sortDropdown {
    color: colors.$gray-100;
    gap: 0;
  }
  ```

  Find a useful reference for color token mappings [here](https://carbon-elements.netlify.app/colors/examples/preview/).

- Use SASS [features](https://sass-lang.com/documentation) like interpolation, at-rules, mixins, and functions to make your styles more reusable and maintainable.
- If you want to apply styles based on the user's viewport size, use our predefined [breakpoints](https://github.com/openmrs/openmrs-esm-core/blob/main/packages/framework/esm-styleguide/src/breakpoints/index.ts). For example, to apply different styles for tablet and desktop viewports, do this:

  ```scss
  // Tablet viewports
  :global(.omrs-breakpoint-lt-desktop) {
    .form {
      height: calc(100vh - 9rem);
    }
  }

  // Desktop viewports
  :global(.omrs-breakpoint-gt-tablet) {
    .form {
      height: calc(100vh - 6rem);
    }
  }
  ```

  <Callout emoji="ℹ️" type="info">
    Make sure to scope your styles under a class name (such as `.form` in the example above) to avoid them affecting
    other components.
  </Callout>

- Use the [classnames](https://npm.im/classnames) library to conditionally apply styles to an element. Consider using classnames if you're interpolating multiple class names into a string. For example, the following snippet:

  ```tsx
  <NumberInput
    allowEmpty
    className={`${styles.textInput} ${val.className}`}
    // other props omitted for brevity
  />
  ```

  Could be replaced by:

  ```tsx
  import classnames from "classnames";

  <NumberInput
    allowEmpty
    className={classNames(styles.textInput, val.className)}
    // ... other props omitted for brevity
  />;
  ```

  The following snippet shows a more advanced case - a `div` styled with multiple conditional styles:

  ```tsx
  return (
    <div
      className={`${styles.textInputContainer} ${disabled && styles.disabledInput} ${
        !isWithinNormalRange && styles.danger
      } ${useMuacColors ? muacColorCode : undefined}`}
    >
      // ... details omitted for brevity
    </div>
  );
  ```

  You can refactor this snippet to leverage `classnames` as follows:

  ```tsx
  import classNames from "classnames";

  const containerClasses = classNames(styles.textInputContainer, {
    [styles.disabledInput]: disabled,
    [styles.danger]: !isWithinNormalRange,
    [muacColorCode]: useMuacColors,
  });

  return <div className={containerClasses}>// ... details omitted for brevity</div>;
  ```

## Search inputs

- Debounce search inputs to prevent unnecessary requests to the backend. Use the [useDebounce](https://github.com/openmrs/openmrs-esm-core/blob/2396ab96a37bc7202c853110969d82c17fe098a6/packages/framework/esm-react-utils/src/useDebounce.ts) hook to debounce search inputs. Here's a snippet (some bits are omitted for brevity) showing how you could use the hook:

  ```tsx
  const [searchTerm, setSearchTerm] = useState("");
  const debouncedSearchTerm = useDebounce(searchTerm);

  return (
    <TableToolbarSearch
      onChange={(e: React.ChangeEvent<HTMLInputElement>) => setSearchTerm(e.target.value)}
      placeholder={t("searchThisList", "Search this list")}
    />
  );

  // Do something with the debouncedSearchTerm
  ```

- Use [fuzzy](https://npm.im/fuzzy) to implement fuzzy search. Fuzzy search is a strategy for matching search terms that are similar to, but not exactly the same as, the search term. For example, if the search term is `John`, fuzzy search will match `Jon`, `Jhon`, and `Johhn`. This is useful for matching search terms that are misspelled or contain typos. Here's how we can leverage fuzzy to enhance the search experience from the snippet above:

  ```tsx
  const [filter, setFilter] = useState("");

  const filteredForms: Array<TypedForm> = useMemo(() => {
    if (!debouncedSearchTerm) {
      if (filter === "Retired") {
        return forms.filter((form) => form.retired);
      }

      if (filter === "Published") {
        return forms.filter((form) => form.published);
      }

      if (filter === "Unpublished") {
        return forms.filter((form) => !form.published);
      }

      return forms;
    }

    return debouncedSearchTerm
      ? fuzzy
          .filter(debouncedSearchTerm, forms, {
            extract: (form: TypedForm) => `${form.name} ${form.version}`,
          })
          .sort((r1, r2) => r1.score - r2.score)
          .map((result) => result.original)
      : forms;
  }, [filter, forms, debouncedSearchTerm]);
  ```

  We're using the `debouncedSearchTerm` from the snippet above to filter the list of forms. We're also using the `extract` option to tell fuzzy how to extract the search term from the form. In this case, we're extracting the search term from the form's name and version. This is because we want to match forms that contain the search term in their name or version. Finally, we're sorting the results by score, which is a measure of how closely the search term matches the form.

## Internationalization

- Do not manually edit any of the locale-specific translation files in the `translations` directory. Run the `extract-translations` script instead to keep the `en.json` file in sync with the translation keys in the codebase.
- Use the [useTranslation](https://react.i18next.com/latest/usetranslation-hook) hook to translate strings in your components.
- Use the [Trans](https://react.i18next.com/latest/trans-component) component to translate strings that contain HTML tags.
- To handle pluralization, use the following pattern:

  ```tsx
  // If there's only one risk flag, the string "1 risk flag" is displayed.
  // If there are multiple risk flags, the string "{count} risk flags" is displayed
  // e.g. "3 risk flags".
  <span className={styles.flagText}>
    {t("flagCount", {
      count: riskFlags.length,
    })}
  </span>
  ```

  The corresponding keys and strings for the code above should look like this:

  ```json
  "flagCount_one": "{{ count }} risk flag",
  "flagCount_other": "{{ count }} risk flags"
  ```

## Error handling

- Use `try/catch` blocks to handle errors that could occur during runtime. Render an error snackbar to the user with a descriptive error message when an error occurs.

  ```tsx
  try {
    await savePatientData(patient);
    showSnackbar({ message: t('patientSaved', 'Patient data saved successfully') });
  } catch (error) {
    showSnackbar({
      title: t('errorSavingPatient', 'Error saving patient'),
      kind: 'error',
      description: error?.message ?? t('unknownError', 'An unknown error occurred'),
    });
  }
  ```

- Don't check the response status of a request to determine whether to show a success snackbar. Instead, always show a success snackbar after a request is successful. `openmrsFetch` will throw an error if the request fails, so you don't need to check the response status to determine whether to show a success or error snackbar.

  ```tsx
  // Don't do this
  saveVisit(visitPayload).then((response) => {
    if (response.status === 201) {
      // Handle the success case
    } else {
      // Handle the error case
    }
  });
  ```

  ```tsx
  // Instead, do this:
  saveVisit(visitPayload).then(() => {
    // Handle the success case
  }).catch((error) => {
    // Handle the error case
  });
  ```

  Alternatively, you can use `async/await` syntax to handle the success and error cases:

  ```tsx
  try {
    await saveVisit(visitPayload);
    // Handle the success case
  } catch (error) {
    // Handle the error case
  }
  ```

- When handling errors in async functions, prefer `async/await` over promise chains for better readability and error handling clarity. For example:

  ```tsx
  // Avoid promise chains
  savePatientData(patient)
    .then((response) => {
      showSnackbar({ kind: 'success', title: t('patientSaved', 'Patient data saved successfully') });
      return response;
    })
    .then(processPatientData)
    .catch((error) => {
      showSnackbar({
        title: t('errorSavingPatient', 'Error saving patient'),
        kind: 'error',
        description: error?.message
      });
    });

  // Prefer async/await
  async function handleSavePatient(patient) {
    try {
      await savePatientData(patient);
      showSnackbar({ kind: 'success', title: t('patientSaved', 'Patient data saved successfully') });
    } catch (error) {
      showSnackbar({
        title: t('errorSavingPatient', 'Error saving patient'),
        kind: 'error',
        description: error?.message
      });
    }
  }
  ```

  The `async/await` approach:
  - Makes the code flow more readable and sequential.
  - Simplifies error handling with a single try/catch block.
  - Makes it easier to debug since stack traces are more meaningful.
  - Allows easier handling of multiple async operations.

  Use a `finally` block to execute cleanup code that should run regardless of whether the operation succeeded or failed:

  ```tsx
  async function handleSavePatient(patient) {
    try {
      // ...
    } catch (error) {
      // Handle the error case
    } finally {
      // Do any additional cleanup work
      closeModal();
    }
  }
  ```

## Testing

- [Avoid the test user](https://kentcdodds.com/blog/avoid-the-test-user).
- Avoid testing implementation details. Instead, test the component's public API. This makes it easier to refactor the component without having to rewrite the tests.
- Follow the guidelines outlined [here](https://kentcdodds.com/blog/common-mistakes-with-react-testing-library).
- Don't make these common testing [mistakes](https://kentcdodds.com/blog/common-testing-mistakes).
- [Write fewer, longer tests](https://kentcdodds.com/blog/write-fewer-longer-tests).
- Structure large test suites using [object page models](https://playwright.dev/docs/pom) when writing e2e tests using Playwright.
- Follow the e2e testing [best practices](https://playwright.dev/docs/test-best-practices) outlined in the Playwright docs.
- When stubbing out functionality from `@openmrs/esm-framework`, follow the mocking patterns described [here](/docs/frontend-modules/unit-and-integration-testing#mocking-patterns).

## Performance

- Use React's built-in performance optimization hooks judiciously:
  - `useMemo` for expensive computations.
  - `useCallback` for stable function references.
  - `memo` for preventing unnecessary re-renders of complex components.

  ```tsx
    // Good - memoizing an expensive computation
    const sortedItems = useMemo(() => {
      return items
        .slice()
        .sort((a, b) => b.timestamp - a.timestamp);
    }, [items]);

    // Good - stable callback for child components
    const handleSubmit = useCallback((data: FormData) => {
      mutate(data);
    }, [mutate]);
    ```

- Use [element optimization](https://kentcdodds.com/blog/optimize-react-re-renders) to avoid unnecessary re-renders. If you give React the same element reference, it will skip rendering the component.
- Use the appropriate lifecycle registration method based your component's loading requirements:
  - Use `getAsyncLifecycle` to register modals, workspaces and other components that can be loaded on-demand. 

  ```tsx
  // Good - modal loaded only when needed
  export const markPatientAliveModal = getAsyncLifecycle(() => import('./mark-patient-alive.modal'), options);
  ```

  - Use `getSyncLifecycle` for components that need to be available immediately on page load:

  ```tsx
  // Good - component included in the main bundle
  export const startVisitForm = getSyncLifecycle(startVisitFormComponent, {
    featureName: 'start-visit-form',
    moduleName,
  });
  ```

  The key difference between the two is that `getAsyncLifecycle` creates a separate chunk for the component in your app's code split. This chunk gets loaded on-demand, which can improve the initial load time of your application. On the other hand, `getSyncLifecycle` includes the component in the main bundle, ensuring that it's available immediately on page load. Use each approach when appropriate to optimize the performance of your application. Read more about the difference between static and dynamic metadata [here](/docs/migrate-to-core-v5).

- Prefer using [icons](https://zeroheight.com/23a080e38/p/993dce-iconography) and [pictograms](https://zeroheight.com/23a080e38/p/396ba7-pictograms) from the CarbonMRS icon library over the `@carbon/react/icons` package. The CarbonMRS library is optimized for our use case and avoids potential tree-shaking issues that can occur with the Carbon icons package.

- Consider using prefetching to improve the responsiveness of your application. Prefetching can be particularly useful in these cases:
  - Prefetching data for items that are likely to be accessed next:

   ```tsx
  // Prefetch the next page of results
  const prefetchNextPage = () => {
    void mutate(`/ws/rest/v1/patient?startIndex=${currentPage + 1}`);
  };
  ```

  - Preloading data using SWR's [preload API](https://swr.vercel.app/docs/prefetching) when hovering over links or buttons:

  ```tsx
  // Preload form schemas when hovering over links in the form builder
  <ConfigurableLink
    className={styles.link}
    to={editSchemaUrl}
    templateParams={{ formUuid: form?.uuid }}
    onMouseEnter={() => void preload(`/ws/rest/v1/form/${form?.uuid}?v=full`, openmrsFetch)}
  >
    {form.name}
  </ConfigurableLink>
  ```

  Remember that while prefetching can improve the user experience, it should be used judiciously to avoid unnecessary network requests and data usage.

- Tweak your SWR configuration appropriately to optimize performance. O3 uses a [global SWR configuration](https://github.com/openmrs/openmrs-esm-core/pull/1157) that disables most automatic revalidations. Because the [SWRConfig component](https://swr.vercel.app/docs/global-configuration.en-US) merges configurations from the parent context, you can override options in the global configuration on a per-component basis. Alternatively, you can specify a custom configuration at a per-hook level. Each SWR hook accepts an options object as an argument, which you can use to customize the behavior of the hook.

  ```tsx
  // Global configuration in the OpenMRS component decorator
  const defaultSwrConfig = {
    // max number of retries after requests have failed
    errorRetryCount: 3,
    // default fetcher function
    fetcher: openmrsFetch,
    // only revalidate once every 30 minutes
    focusThrottleInterval: 1800000,
    revalidateIfStale: true,
    // disable automatic revalidations by default
    revalidateOnFocus: false,
    revalidateOnReconnect: false,
    refreshInterval: 0,
  };

  <SWRConfig value={defaultSwrConfig}>
    <ComponentContext.Provider value={this.state.config}>
      {opts.disableTranslations ? (
        <Comp {...this.props} />
      ) : (
        <I18nextProvider
          // props omitted for brevity
        >
          <Comp {...this.props} />
        </I18nextProvider>
      )}
    </ComponentContext.Provider>
  </SWRConfig>
  ```

  ```tsx
  // Component-level configuration using the SWRConfig component
  <SWRConfig value={{ revalidateOnFocus: true, revalidateOnReconnect: true }}>
    <Component />
  </SWRConfig>
  ```

  ```tsx
  // Custom configuration at a per-hook level
  const { data } = useSWR('/ws/rest/v1/patient?v=full', openmrsFetch, {
    revalidateOnFocus: true,
    revalidateOnReconnect: true,
  });
  ```
  
- Avoid common performance pitfalls:
  - Don't create new objects or arrays in render
  - Avoid inline function definitions in JSX
  - Don't use index as key in lists
  - Prevent unnecessary re-renders by proper state management

  ```tsx
  // Bad - new object created every render
  <Component style={{ margin: '10px' }} />

  // Good - stable object reference
  const styles = { margin: '10px' };
  <Component style={styles} />

  // Bad - new function created every render
  <Button onClick={() => handleClick(id)} />

  // Good - stable function reference
  const handleButtonClick = useCallback(() => {
    handleClick(id);
  }, [id, handleClick]);
  <Button onClick={handleButtonClick} />
  ```

- Monitor your application's performance using the [React DevTools Profiler](https://react.dev/learn/react-developer-tools). To profile your app, you could run both your app and the O3 app shell locally and then use the [import map overrides mechanism](/docs/frontend-modules/development#import-map-overrides) to load your app in the O3 app shell. You could then open the React DevTools Profiler in your browser and start a profiling session. Things to watch out for include:
  - Components with frequent re-renders
  - Components that are slow to render
  - Long task in the main thread
  - Components that could be memoized
